---
title: 【C++】移动语义
date: 2023-09-19 11:48:39
tags: "C++"
---

# 移动语义

## 右值引用

<font color='IndianRed'>右值引用只能绑定到一个将要销毁的对象</font>

左值和右值都是表达式的属性（表达式的属性也就只有两种：要么是左值要么是右值）左值可以位于赋值语句左侧，右值则不能。

需要右值的地方可以用左值替代，这很常见。

不能把右值当成左值，这句话要怎么理解。举例来说：

```c++
42 = i;	//错误
```



> 一个技巧
>
> ```c++
> int i = 42;
> int &ri = i;
> int &&li = i*42;
> ```
>
> 我们一般习惯从右往左读赋值运算符的代码。但是对于引用类型的赋值，不妨试试从左往右读，读成“把一个左值引用绑定到xxx”。这样在阅读时会方便许多





* 赋值运算符：  （左值） =  ， ——>左值

* &取地址： 需要左值，得到的是右值

* 解引用，迭代器解引用。内置下标，string,vector的下标运算，这些的结果都是左值

* 内置和迭代器的递减递增，需要左值，得到左值

  > 类型推导decltype，会根据表达式是左值还是右值返回不同结果

绑定规则：

有些表达式（函数，运算符、前置递增/减）会返回左值引用，可以将左值引用绑定到这些表达式的结果上。

返回非引用类型的函数，以及算术、关系、位、后置递增，都是返回右值引用。不能将左值引用绑定到这类表达式上。但是可以将<font color='IndianRed'>一个const的左值引用或者右值引用绑定到这类表达式</font>。即：

```
T&& = 右值表达式
const T& = 右值表达式
```



变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式。<font color='IndianRed'>变量表达式都是左值</font>。

所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用。如：

```c++
int &&r1 = 42;
int &&r2 = r1; //wrong
```

### std::move

move函数用来获得绑定到左值上的右值引用。



```c++
int &&r1 = 42;
int &&r2 = std::move(r1); //right
```

调用move后，我们不能对移后源对象的值做任何假设。

## 移动构造和移动赋值

一个对象移动数据不会销毁此对象，但有时，在移动操作完成后，源对象会被销毁。因此，在写移动操作时必须满足，移动后源对象可被析构。

移动构造用于完成资源移动。

除此之外，移动构造还要确保移后源对象处于一个销毁它是无害的状态。

```c++
StrVec::StrVec(StrVec &&s) noexcept		//移动构造不应该抛出异常
    :elements(s.elements),first_free(s.first_free),cap(s.cap)
    {
        s.elements = s.first_free = s.cap = nullptr;	//保证对s运行析构函数是安全的
    }
```

移动构造函数不分配任何新的内存，它接管给定的内存。

> 为什么任务移动操作不会抛出异常呢？
>
> 因为移动操作一般不分配任何资源。



### 移动赋值

```c++
StrVec& StrVec::operator==(StrVec &&rhs)
{
    if(this != &rhs)
    {
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        //将rhs置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```





> vector重新分配过程中是移动还是拷贝

...

### 合成的移动操作

如果一个类没有自己的移动操作。类会使用拷贝操作来代替移动操作。

如果一个类没有任何拷贝控制成员，且类的每个成员都可以移动时，编译器会为它合成移动构造函数和移动赋值函数。

关于什么时候不会定义合成的移动操作

1. 类成员没有移动操作（合成的或者自定义的）
2. 类的析构函数被定义为删除的。
3. 有const的成员或引用

> 主要记住：有拷贝操作，就不会合成移动操作

### 匹配拷贝构造还是移动构造

如果一个类既有拷贝构造，又有移动构造。该如何拷贝。

= 右侧是左值，则使用拷贝赋值

= 右侧是右值，使用移动赋值。<font color='IndianRed'>因为右值要想匹配到拷贝赋值运算，需要一次到const的转换</font>

> 如果一个类只有拷贝，没有移动构造，则=右侧是右值也只能使用拷贝。

举例来说：

```c++
StrVec getVec(istream &);

StrVec v1,v2;
v1 = v2; //1
v2 = getVec(cin);//2
```

首先拷贝构造函数的参数是const StrVec&, 移动构造函数的参数是StrVec&&

1:v2的类型是StrVec，可以匹配拷贝。但不能匹配移动。

2:getVec(cin)返回的是右值，两个形参都可以匹配。但是匹配const StrVec&需要一次const转换，所以移动构造的StrVec&&胜出。

### 既是移动赋值运算，又是拷贝赋值运算

```c++
HasPtr
{
public:
    //移动构造
    HasPtr(HasPtr &&p)noexcept:ps(p.ps),i(p.i)
    {p.ps = p.i =0;}
    //移动赋值运算符和拷贝赋值运算符合体
    HasPtr& operator=(HasPtr rhs)
    {	swap(*this,rhs);	return *this;}
}
```

举例说明：

hp = hp2;	//hp是左值，hp2在传参数调用拷贝构造

hp = std::move(hp2);	//右值引用，传参时移动构造是精准匹配

我认为这是一个难点：当std::move(hp2)作为实参匹配形参HasPtr时，首先要进行一次构造。而移动构造的StrVec&&精准匹配，胜出。此时是把hp2的成员移动到了rhs，然后swap，此时rhs中的指针指向的都是hp的资源。离开函数是rhs销毁，hp原来指向的资源也被释放，hp现在指向的都是hp2的资源，符合移动语义。

